---
layout: post
title: Python - Call by Reference, Call by Value
categories: [Python]
excerpt_separator:  <!--more-->
---

## 개요
Python은 함수 인자를 받을때 어떤 방식으로 data를 전달받는가?   
Call by Reference 일까? Call by Value 일까?

결론부터 말하자면 어떠한 타입의 data를 인자로 받느냐에 따라 달라지게 된다.   
Call by assignment라 할 수 있는것이다.

Python의 자료형에는 immutable(불변), mutable(가변)이 있다.   
int, str등의 자료형은 불변이고, list, dictionary같은 자료형은 가변인데, 불변 타입의 자료형을 인자로 받으면 Call by Value로 작동하고, 가변 타입을 인자로 받으면 Call by Reference가 된다.

어떤 원리로 이렇게 작동하게 되는 것일까?   

Python은 '모든것이 객체(Object)로 이루어져 있다.'라는 대전제에서 시작한다.

Python의 변수는 값을 메모리에 할당하는 상자가 아닌, '만들어진 객체의 이름표'라고 생각해야 한다.   

예를 들어 'a = 4300' 이라는 코드가 작성되었다면, 4300 이라는 int 값이 객체로 생성되고, 해당 객체를 가리키는 이름표로 a를 붙인 것이 된다. 이후 이 4300이라는 값을 연산이나 자료형 변경등의 이유로 변화시켜야 할 때에는, 원래 있던 값을 직접 변동시키지 않고 (불변이기 때문에), 일단 변경을 진행해 결과 값을 만든후, 해당 값으로 새로운 객체를 생성한뒤 a라는 이름표를 떼어내서 새로운 값의 이름표로 할당하게 되는것이다. 이후 원래 생성되었던 객체는 참조하는 곳이 없다면 소멸이 된다.

코드로 예를 들어보면 다음과 같다.
```{.python}
# a 라는 변수명을 4300이라는 int 객체의 이름표로 선언한다.
>>> a = 4300
# a가 가리키는 객체의 id를 조회해본다 (해당 값은 실행때마다 달라 질 수 있다.)
>>> id(a)
45620112

"""
+200이라는 연산을 실행할때, python 내부에서는 
'4300이라는 int 객체에 200을 더하여 4500이라는 새 int 객체를 만든후, a라는 이름표를 옮긴다.' 
라는 변화가 일어난다.
"""
>>> a += 200
>>> a
4500

# id를 조회해보면 값이 변경되었음을 알 수 있다.
>>> id(a)
45620496

# 문자열로 변경시에도 마찬가지임을 알 수 있다.
>>> a = str(a)
>>> a
'4500'
>>> id(a)
45176288
```

- - -
### Call by Value
integer 값을 인자로 받아 내부에서 +100을 한 뒤 값을 리턴하는 함수가 있다고 가정한다.
해당 함수는 integer값을 인자로 받는데, python에서는 변수가 global인지 local인지 정보를 저장하는 namespace가 따로 존재한다. 따라서 전역 변수를 인자로 받더라도 함수 내에서 변화 할 경우 지역 변수로 작동하게 된다.

```{.python}
def add_value(value):
    # 전역 변수를 인자로 받았으므로 일단 '전역 변수' value를 참조한다.
    print("참조 주소 : {}".format(id(value)))
    # 함수 내부에서 +100을 진행하고, '지역 변수' value에 해당 객체를 매치한다.
    value += 100
    # 따라서 여기서는 '지역 변수' value를 참조하게 된다.
    print("더하기 연산 이후 참조 주소 : {}".format(id(value)))

    return value

>>> value = 4300
>>> id(value)
45620208
>>> value = add_value(value)
참조 주소 : 45620208
더하기 연산 이후 참조 주소 : 48312400
# 연산 이전의 print 에서는 전역 변수가, 이후의 print 에서는 지역 변수가 참조된 것을 볼 수 있다.

"""
지역 변수로 만들어진 4400이라는 int 객체에 value 이름표를 옮겼다.    
value가 참조하는 객체 주소가 add_value 함수에서 만들어진 지역 변수의 주소로 변화한 것을 볼 수 있다.
"""
>>> value
4400
>>> id(value)
48312400
```

integer값은 불변이므로 원래 있던 객체의 값을 함수 내에서 변화시킨 후, 그 결과값으로 새 객체를 만들어 함수내의 local 변수로 사용한 것이다. 따라서 불변 자료형을 인자로 받을 시 Call by Value로 작동하게 되는 것이다.    

따라서 함수 내에서 어떠한 변화가 진행되어도 변수명이 가리키는 객체가 이미 다르므로 리턴값으로 새롭게 값을 할당 하지 않는 한 원본의 변화는 없게 된다.

- - -
### Call by Reference
list 자료형을 받아서 "new"라는 문자열을 일괄적으로 추가하는 함수가 있다고 가정한다.
이 경우 python은 list 자료형이 가변이기 때문에, 값을 복사하지 않고 해당 list 객체를 그대로 인자로 전달한다.

```{.python}
def append_value(data_list):
    print("리스트 주소 : {}".format(id(data_list)))
    data_list.append("new")
    print("append 이후 리스트 주소 : {}".format(id(data_list)))

>>> a = []
>>> id(a)
46223560

>>> append_value(a)
리스트 주소 : 46223560
append 이후 리스트 주소 : 46223560
# a라는 리스트를 함수에서 전달받아, 함수내에서 "new"라는 문자열을 추가했지만 참조하는 객체의 주소에는 변화가 없다.

# 함수에서 별도의 리턴값을 받지 않았지만, a라는 list 자료형에 함수 내에서 추가한 "new"가 추가 되어있는 것을 확인 할 수 있다.
>>> a
['new']
>>> id(a)
46223560

"""
반복 진행해도 주소에는 변화가 없다는 것을 알 수 있다. 
또한 "new" 문자열이 추가가 되는 것을 알 수 있다.
"""
>>> append_value(a)
리스트 주소 : 46223560
append 이후 리스트 주소 : 46223560
>>> a
['new', 'new']
>>> id(a)
46223560

```

list 자료형은 값을 추가하거나, 삭제하는등의 변화가 가능한 자료형으로 가변이다. 일단 함수에서 data를 인자로 받을때 기존 객체를 참조하는 것은 양쪽이 동일하나, 값의 변화가 생길경우 불변으로 값이 변화 할 수 없는 int, str 등의 자료형은 값이 변화 할 시 새 객체를 만들게 되지만, list등의 자료형은 변화가 가능하므로 새 객체를 만들지 않고 기존 자료형을 변화시키게 되는것이다. 

따라서 가변 자료형의 경우는 Call by Reference가 된다.

- - -
## 정리
python은 전달받는 인자의 자료형으로 호출 방식이 결정 된다.   
불변형은 Value로, 가변형은 Reference로 전달받게 되는데, 이유는 python이 객체로 모든 자료를 주고 받기 때문이다.
따라서 python에서 인자로 data를 전달할때, 함수 내부에서 어떤식으로 data를 handling 하는지 확인 하지 않는다면 의도치 않은 변화가 생길 수 있으므로 주의해야 한다. 코드 작성시 반드시 이 점을 확인해야 한다.
